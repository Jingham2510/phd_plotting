"""
Script that plots the force_displacement data generated by rob_controls force_displacement testing

data format:
linenum date/time [x,y,z] [ori_x, ori_y, ori_z] [force_x,force_y,force_z,force_Rx,force_Ry,force_Rz]


It will plot the position, forces, velocity and acceleration

"""

import matplotlib.pyplot as plt
from tools import *
from math import sqrt
from statistics import fmean
import matplotlib.patches as mpatches
from config import ConfigHandler

#Config file from the test
config_data = FileNotFoundError



phase2_marker = -1
phase3_marker = -1

#Organise the plotting
def main(filepath, rust_check):

    datetimes = []
    pos = []
    ori = []
    forces = []
    force_error = []
    embed_height = []

    line_cnt = 0
    phase2_marker = -1
    phase3_marker = -1
    #Open the file
    with open(filepath) as file:
        #Go through every line
        for line in file:
            #Ensure line isnt empty
            if line and not(line.startswith("!")):
                #Split the line up
                tokens = data_split(line, rust_check)     
               
                
                
                #Append the time data
                datetimes.append(tokens[0])

                #Append the position data
                pos.append(tokens[1])
                
                #Append the force data
                ori.append(tokens[2])

                forces.append(tokens[3])

                if rust_check:
                    force_error.append(tokens[4])

                    


            elif line.startswith(("!")) and "PHASE 2 STARTED" in line:
                phase2_marker = line_cnt
            elif line.startswith(("!")) and "PHASE 3 STARTED" in line:
                phase3_marker = line_cnt

            line_cnt = line_cnt + 1


    #print(f"2:{phase2_marker}")
    #print(f"3:{phase3_marker}")

    #Calculate the time differences 
    time = calc_time_passed(datetimes, rust_check)



    #Turn the positions into numbers
    pos = str_to_array(pos)

    for item in pos:
      
        embed_height.append(config_data.min_embed_height - item[2])

    #Turn the forces into numbers
    force = str_to_array(forces)

    if rust_check:
        force_error = str_to_array(force_error)


    #Check that the data arrays are the same lengths
    if(not len(time) == len(pos) == len(forces)):
        print("DATA ARRAYS ARE INCONSISTENT LENGTH")

        print(f"time: {len(time)}, pos: {len(pos)}, forces: {len(forces)}")

        raise Exception()
    

    #Calculate the velocities
    vels = xyz_integ_avg(time, pos)   


    #Calculate the accelerations
    accs = xyz_integ_avg(time, three_arrs_to_threeD(vels[0], vels[1], vels[2]))

  
    #Create subfigure array for plots
    #We want to plot force vs pos?
    #Can decide later

    start = 0
    stop = 40000
    

    print(f"Settling time: {max(time)}")

    #plot_force_history(force, time)
    #highlight_three_phase(force, time, phase2_marker, phase3_marker)
    #plot_pos(pos, time, False)
    plot_height(pos, time)
    plot_embed_height(embed_height, time)
    #plot_force_vectors(pos[start:stop], force[start:stop], False)
    #plot_work_step(pos, force, time)
    #plot_work_over_time(pos, force, time)
    #plot_z_velocity(vels[2], time)
    

    #Ensure that the phase markers have been found before trying to isolate the force-phase data
    #Plot up to phase 2 (i.e. plot phase 1)
    if phase2_marker > 0 and True:
        plot_force_history(force[:phase2_marker], time[:phase2_marker])
    #Plot phase 2 to phase 3 marker
    if phase2_marker > 0 and phase3_marker > 0 and False:
        plot_force_error(force_error[phase2_marker:phase3_marker-1], time[phase2_marker:phase3_marker-1])
    #No phase 3 marker so just plot post-phase 2 
    elif phase2_marker > 0 and False:
        plot_force_error(force_error[phase2_marker:], time[phase2_marker:])
        #Plot post phase 3 marker
    if phase3_marker > 0 and False:
        plot_force_error(force_error[phase3_marker:], time[phase3_marker:])

    return





#Plot the  x vs y pos vs force
def plot_force_history(force, time):


    #Create force array contianing data of each axes
    forces  = [[],[],[],[],[],[]]

    
    #for i in force:
        #forces[0].append(abs(i[0]))
        #forces[1].append(abs(i[1]))
        #forces[2].append(abs(i[2]))
        #forces[3].append(abs(i[3]))
        #forces[4].append(abs(i[4]))
        #forces[5].append(abs(i[5]))
    
    for i in force:
        forces[0].append(i[0])
        forces[1].append(i[1])
        forces[2].append(i[2])
        forces[3].append(i[3])
        forces[4].append(i[4])
        forces[5].append(i[5])
    

    print(f"MIN FORCE:{min(forces[2])}")

    fig, ax1 = plt.subplots()

    ax1.set_xlabel("Time (S)", fontsize=12)
    ax1.set_ylabel("Force (N)", fontsize=12)
    ax1.tick_params(axis="both", which="major", labelsize=12)


    start_val = 0
    
    #Colours selected using https://colorbrewer2.org/#type=qualitative&scheme=Dark2&n=3
    #ax1.plot(time[start_val:], forces[0][start_val:],  label = "$F_x$", color="#1b9e77")
    #ax1.plot(time[start_val:], forces[1][start_val:],  label = "$F_y$", color="#d95f02")
    ax1.plot(time[start_val:], forces[2][start_val:],  label = "$F_z$", color="#7570b3")
    plt.grid(True)

    



    #ax2 = ax1.twinx()
    #ax1.set_ylabel("Moment (N/m)")
    
    #ax1.plot(time, forces[3],  label = "$M_x$", color="darkorange", linestyle="dashed", linewidth = "0.5")
    #ax1.plot(time, forces[4],  label = "$M_y$", color="navy", linestyle="dashed", linewidth = "0.5")
    #ax2.plot(time, forces[5],  label = "$M_z$", color="cyan", linestyle="dashed", linewidth = "0.5")
    
    
    fig.legend(prop={"size": 16})


    plt.show()


def plot_pos(pos, time, include_z):

    x = [i[0] for i in pos]
    y = [i[1] for i in pos]

    if include_z:
        z = [i[2] for i in pos]



    if not include_z:

        """
        plt.plot(x[10:], y[10:])

        plt.xlabel("x (mm)", fontsize=24)
        plt.ylabel("y (mm)", fontsize=24)
        plt.tick_params(axis="both", which="major", labelsize=24)
        plt.grid(True)

        plt.show()
        """

        plt.plot(time[10:], x[10:])

        plt.xlabel("time (s)", fontsize=24)
        plt.ylabel("x (mm)", fontsize=24)
        plt.tick_params(axis="both", which="major", labelsize=24)
        plt.grid(True)
        plt.show()


        plt.plot(time[10:], y[10:])
        plt.xlabel("time (s)", fontsize=24)
        plt.ylabel("x (mm)", fontsize=24)
        plt.tick_params(axis="both", which="major", labelsize=24)
        plt.grid(True)

        plt.show()

    else:

        ax = plt.figure().add_subplot(projection='3d')


        plt.plot(x[10:], y[10:], z[10:])

        plt.xlabel("x (mm)", fontsize=24)
        plt.ylabel("y (mm)", fontsize=24)
        ax.set_zlabel("z (mm)", fontsize=24)
        plt.grid(True)
        
        plt.tick_params(axis="x", which="major", labelsize=24)
        plt.tick_params(axis="y", which="major", labelsize=24)
        plt.tick_params(axis="z", which="major", labelsize=24)

        plt.show()


    return


"""
Plots the height over time
"""
def plot_height(pos, time):

    z = [i[2] for i in pos]

    plt.plot(time, z)
    plt.xlabel("Time (sec)", fontsize=24)
    plt.ylabel("Height (mm)", fontsize=24)
    plt.tick_params(axis="x", which="major", labelsize=24)
    plt.tick_params(axis="y", which="major", labelsize=24)
    plt.grid(True)

    plt.show()

    return

"""
plots the work (displacement*force) at each step against time
"""
def plot_work_step(pos, forces, time):


    plt.plot(time, calc_work(pos, forces, time))


    plt.xlabel("time(sec)", fontsize=12)
    plt.ylabel("Work at step (J)", fontsize=12)
    plt.tick_params(axis="both", which="major", labelsize=12)

    plt.show()


    return


def plot_z_velocity(z_vel, time):

    plt.plot(time, z_vel)

    plt.xlabel("time(sec)")
    plt.ylabel("Velocity (mm/s)")

    plt.show()


    return


"""
Plot the total work over time
"""
def plot_work_over_time(pos, forces, time):


    work_steps = calc_work(pos, forces, time)
    curr_work = 0
    total_work = []

    for i in range(len(work_steps)):
        curr_work += work_steps[i]
        total_work.append(curr_work)


    plt.plot(time, total_work)


    plt.xlabel("time(sec)", fontsize=12)
    plt.ylabel("Work done (J)", fontsize=12)
    plt.tick_params(axis="both", which="major", labelsize=12)
    plt.grid(True)
    plt.show()





    return
"""
Plots the force vectors in 3D space
"""
def plot_force_vectors(pos,forces,threeD):   

    
    #Previous force vector determines next starting position
    x = []
    y = []
    z = []
    u = []
    v = []
    w = []

    #Create the force vectors
    for i in range(len(forces)):

        #Starting position is based on previous vector direction
        x.append(pos[i][0])
        y.append(pos[i][1])
        z.append(pos[i][2])

        #current vector direction based on applied forces
        u.append(forces[i][0])
        v.append(forces[i][1])
        w.append(forces[i][2])


    #Create the axes and figure

    if threeD:
        ax = plt.figure().add_subplot(projection="3d")

        ax.quiver(x, y, z, u, v, w, length = 0.01)

        ax.set_aspect("equal")

    else:
        plt.quiver(x, y, u, v)

    

    plt.show()

    return



#Plot the force error overtime
def plot_force_error(error, time):


    #Calculate the average force error over the whole thing and plot the line
    error = [x[0] for x in error]
    avg_err = fmean(error)
    print(f"AVG ERR: {avg_err}")

    red_patch = mpatches.Patch(color="r", label = f"Avg: {round(avg_err, 3)}")

    plt.plot(time, error)
    plt.axhline(avg_err, color = "r")
    

    plt.grid(True)
    plt.legend(handles=[red_patch])

    #plt.title("Force Error (variation from target)")
    plt.xlabel("time(sec)", fontsize=12)
    plt.ylabel("Force Error (N)", fontsize=12)

    plt.show()


    return


def highlight_three_phase(force, time, phase2_marker, phase3_marker):
        #Create force array contianing data of each axes
    forces  = [[],[],[],[],[],[]]

    
    #for i in force:
        #forces[0].append(abs(i[0]))
        #forces[1].append(abs(i[1]))
        #forces[2].append(abs(i[2]))
        #forces[3].append(abs(i[3]))
        #forces[4].append(abs(i[4]))
        #forces[5].append(abs(i[5]))
    
    for i in force:
        forces[0].append(i[0])
        forces[1].append(i[1])
        forces[2].append(i[2])
        forces[3].append(i[3])
        forces[4].append(i[4])
        forces[5].append(i[5])
    

    print(f"MIN FORCE:{min(forces[2])}")

    fig, ax1 = plt.subplots()

    ax1.set_xlabel("Time (S)", fontsize=24)
    ax1.set_ylabel("Force (N)", fontsize=24)
    ax1.tick_params(axis="both", which="major", labelsize=24)


    start_val = 0
    
    #Colours selected using https://colorbrewer2.org/#type=qualitative&scheme=Dark2&n=3
    #ax1.plot(time[start_val:], forces[0][start_val:],  label = "$F_x$", color="#1b9e77")
    #ax1.plot(time[start_val:], forces[1][start_val:],  label = "$F_y$", color="#d95f02")
    ax1.plot(time[start_val:], forces[2][start_val:],  label = "$F_z$", color="#7570b3")
    plt.grid(True)

    



    #ax2 = ax1.twinx()
    #ax1.set_ylabel("Moment (N/m)")
    
    #ax1.plot(time, forces[3],  label = "$M_x$", color="darkorange", linestyle="dashed", linewidth = "0.5")
    #ax1.plot(time, forces[4],  label = "$M_y$", color="navy", linestyle="dashed", linewidth = "0.5")
    #ax2.plot(time, forces[5],  label = "$M_z$", color="cyan", linestyle="dashed", linewidth = "0.5")
    
    
    fig.legend(prop={"size": 24})


    #Also plot the markers for the relevant phases
    ax1.vlines(time[phase2_marker], max(forces[2]) + 10, min(force[2]) - 20, "red", "--")
    ax1.vlines(time[phase3_marker], max(forces[2])+ 10, min(force[2]) -  20, "red", "--")


    phase_mark_text = {"weight":"semibold",
                       "size":24}

    ax1.text(time[phase2_marker] - 4, -170, "PHASE 1", phase_mark_text)

    ax1.text(time[phase2_marker] + 4, -300, "PHASE 2", phase_mark_text)

    ax1.text(time[phase3_marker] + 4, -300, "PHASE 3", phase_mark_text)


    plt.show()



def plot_embed_height(embed_dat, time):

        plt.plot(time[10:], embed_dat[10:])

        plt.xlabel("time (s)", fontsize=24)
        plt.ylabel("embed height (mm)", fontsize=24)
        plt.tick_params(axis="both", which="major", labelsize=24)
        plt.grid(True)
        plt.show()


if __name__ == "__main__":
    print("FORCE DISPLACEMENT PLOTTING ------------------")

    #test_name = "geo_phase2-500_2"
    test_name = "LONG_speed-10_1"
    CAPTURED_USING_RUST = True

    conf_filepath = "C:\\Users\\User\\Documents\\Results\\DEPTH_TESTS\\" + test_name + "\\conf_" + test_name + ".txt"
    config_data = ConfigHandler(conf_filepath)
    data_filepath = "C:\\Users\\User\\Documents\\Results\\DEPTH_TESTS\\" + test_name + "\\data_" + test_name + ".txt"

    main(data_filepath, CAPTURED_USING_RUST)
